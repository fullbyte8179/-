Технический отчет: Анализ алгоритмов сортировки и поиска
Раздел I: Алгоритмы сортировки
1. Сортировка выбором (Selection Sort) — Реализация на Java

1.1. Суть метода:
Это алгоритмический подход, при котором на каждом шаге итерации производится поиск минимального элемента среди всех еще не упорядоченных значений, с последующим его размещением в начало неотсортированной части массива.

1.2. Объяснение работы алгоритма:

Массив концептуально делится на две секции: отсортированную (в начале) и необработанную (в конце).

В рамках каждой итерации в необработанной секции идентифицируется элемент с наименьшим значением.

Обнаруженный минимальный элемент обменивается местами с первым элементом неотсортированной секции.

С каждой такой итерацией граница отсортированной секции смещается на одну позицию вправо.

Этот цикл операций продолжается до тех пор, пока весь массив не перейдет в отсортированное состояние.

Используемые конструкции Java:

int[]: Декларация массива для хранения целочисленных значений.

for: Циклическая конструкция для организации итераций.

if: Условная инструкция для выполнения сравнений.

Scanner: Класс для обработки консольного ввода.

1.3. Пример выполнения:

Входные данные: 5, затем 64 25 12 22 11

Выходные данные: 11 12 22 25 64

1.4. Детальный анализ временной сложности:

Лучший случай — O(n²): Алгоритм является неадаптивным; даже на предварительно отсортированном массиве он выполнит полный набор сравнений для верификации минимальности каждого элемента.

Средний случай — O(n²): Для случайного набора данных количество операций остается пропорциональным квадрату размера.

Худший случай — O(n²): При любом порядке элементов объем вычислений остается неизменным.

Разбор по операциям:

Количество сравнений: n(n-1)/2, что асимптотически эквивалентно O(n²).

Количество обменов: n-1, что соответствует O(n).

Пространственная сложность: O(1) — сортировка выполняется на месте (in-place).

2. Сортировка обменом (пузырьком) — Реализация на Python

2.1. Суть метода:
Алгоритм, который многократно итерирует по списку, попарно сравнивая смежные элементы и выполняя их обмен, если их порядок нарушен. Процесс повторяется до тех пор, пока не будет достигнута полная упорядоченность.

2.2. Объяснение работы алгоритма:

Алгоритм выполняет многократные проходы по массиву, фокусируясь на сравнении соседних элементов.

В случае, если два смежных элемента расположены в неверной последовательности, они меняются местами.

Каждая полная итерация приводит к тому, что наибольший из оставшихся элементов "всплывает" в конец массива.

Процедура повторяется до момента, когда массив становится полностью отсортированным.

Используемые конструкции Python:

list: Встроенный динамический тип данных.

for ... in range(): Цикл для итерации по числовой последовательности.

if: Условная конструкция для проверки необходимости обмена.

2.3. Пример выполнения:

Входные данные: 7, затем 64 34 25 12 22 11 90

Выходные данные: 11 12 22 25 34 64 90

2.4. Детальный анализ временной сложности:

Лучший случай — O(n): Достигается, если используется оптимизация с флагом, который отслеживает наличие обменов за проход. Для базовой версии — O(n²).

Средний случай — O(n²): В среднем требуется ~n²/2 сравнений. Суммарно: Σ(n-i-1) для i от 0 до n-1 равно n(n-1)/2.

Худший случай — O(n²): На обратно отсортированном массиве выполняются все возможные сравнения и обмены.

Математическое обоснование: Квадратичная сложность является следствием вложенной структуры циклов.

3. Сортировка вставками — Реализация на C++

3.1. Суть метода:
Алгоритм, который строит финальный отсортированный массив итеративно, по одному элементу за раз. Он берет каждый элемент из входной последовательности и помещает его на соответствующую позицию в уже отсортированной части.

3.2. Объяснение работы алгоритма:

Массив мысленно разделяется на отсортированную и неотсортированную части.

Каждый последующий элемент из неотсортированной части вставляется на корректную позицию в отсортированной.

Элементы, которые больше вставляемого, сдвигаются на одну позицию вправо, чтобы освободить для него место.

Процесс продолжается до исчерпания всех элементов в неотсортированной части.

Используемые конструкции C++:

vector: Контейнер из STL для динамических массивов.

for: Внешний цикл для итерации по элементам.

while: Внутренний цикл для поиска позиции и сдвига.

&&: Логический оператор "И".

3.3. Пример выполнения:

Входные данные: 5, затем 12 11 13 5 6

Выходные данные: 5 6 11 12 13

3.4. Детальный анализ временной сложности:

Лучший случай — O(n): Наблюдается на уже отсортированном массиве, когда внутренний цикл while не выполняется.

Средний случай — O(n²): В среднем каждый элемент сдвигается на n/4 позиций.

Худший случай — O(n²): На обратно отсортированном массиве каждый элемент сдвигается на i позиций.

Анализ операций: Для i-го элемента в среднем требуется i/2 сравнений и присваиваний.

4. Сортировка слиянием — Реализация на Java

4.1. Суть метода:
Алгоритм, реализующий стратегию "разделяй и властвуй". Он рекурсивно делит массив на две половины, сортирует каждую из них, а затем объединяет (сливает) отсортированные половины в единый массив.

4.2. Объяснение работы алгоритма:

Применяется стратегия рекурсивной декомпозиции "разделяй и властвуй".

Массив рекурсивно делится пополам до тех пор, пока не образуются подмассивы из одного элемента.

Далее подмассивы сливаются в обратном порядке, формируя отсортированные последовательности.

Процедура слияния заключается в сравнении элементов из двух подмассивов и их последовательном размещении в правильном порядке.

Используемые конструкции Java:

void: Спецификатор типа, указывающий, что функция не возвращает значение.

Рекурсия: Вызов функцией самой себя с измененными параметрами.

System.arraycopy(): Нативный метод для высокопроизводительного копирования массивов.

4.3. Пример выполнения:

Входные данные: 7, затем 38 27 43 3 9 82 10

Выходные данные: 3 9 10 27 38 43 82

4.4. Детальный анализ временной сложности:

Все случаи — O(n log n): Алгоритм всегда выполняет разделение и слияние, независимо от исходного порядка данных.

Математическое доказательство:

Рекуррентное соотношение: T(n) = 2T(n/2) + O(n).

По основной теореме о рекуррентных соотношениях, решением является O(n log n).

Глубина рекурсии: log₂n уровней. На каждом уровне выполняется O(n) операций слияния.

Пространственная сложность: O(n) — требуется дополнительная память для временных массивов.

5. Сортировка Шелла — Реализация на Python

5.1. Суть метода:
Модификация сортировки вставками, которая сначала сортирует элементы, находящиеся на большом расстоянии друг от друга (шаге), а затем постепенно уменьшает этот шаг.

5.2. Объяснение работы алгоритма:

Алгоритм является усовершенствованной версией сортировки вставками.

Сортировка выполняется с определенным шагом (gap), который итеративно уменьшается.

На каждом этапе сортируются элементы, отстоящие друг от друга на расстояние gap.

Когда gap достигает единицы, алгоритм функционирует как стандартная сортировка вставками.

Используемые конструкции Python:

len(): Встроенная функция, возвращающая количество элементов.

//: Оператор для выполнения целочисленного деления.

while: Цикл с условием, выполняющийся до тех пор, пока оно истинно.

5.3. Пример выполнения:

Входные данные: 5, затем 12 34 54 2 3

Выходные данные: 2 3 12 34 54

5.4. Детальный анализ временной сложности:

Сложность зависит от последовательности шагов (gaps):

Последовательность Шелла (n/2, n/4, ...): Худший случай O(n²).

Последовательность Хиббарда (2^k - 1): O(n^(3/2)).

Последовательность Кнута ((3^k - 1)/2): O(n^(3/2)).

Последовательность Седжвика: O(n^(4/3)).

Лучший случай — O(n log n): При оптимальной последовательности промежутков.

Худший случай — O(n²): При неудачном выборе шагов.

Анализ: Эффективность определяется тем, насколько быстро алгоритм устраняет инверсии на ранних этапах.

6. Быстрая сортировка — Реализация на Python

6.1. Суть метода:
Один из наиболее широко используемых алгоритмов, основанный на принципе "разделяй и властвуй". Он выбирает "опорный" элемент и перераспределяет остальные элементы массива на две группы: меньшие и большие опорного, после чего рекурсивно сортирует эти группы.

6.2. Объяснение работы алгоритма:

Применяется стратегия рекурсивной декомпозиции "разделяй и властвуй".

Выбирается опорный элемент (pivot).

Массив делится на три части: элементы меньше pivot, равные pivot и больше pivot.

Рекурсивно применяется к левой и правой частям.

Результаты объединяются в отсортированный массив.

Используемые конструкции Python:

def: Ключевое слово для объявления функции.

if len(arr) <= 1: Условие базового случая рекурсии.

Генераторы списков: Компактный способ фильтрации и создания новых списков.

6.3. Пример выполнения:

Входные данные: 6, затем 10 7 8 9 1 5

Выходные данные: 1 5 7 8 9 10

6.4. Детальный анализ временной сложности:

Лучший случай — O(n log n): Когда pivot каждый раз делит массив пополам. Рекуррентное соотношение: T(n) = 2T(n/2) + O(n).

Средний случай — O(n log n): В среднем pivot близок к медиане. Математическое ожидание времени работы: O(n log n).

Худший случай — O(n²): Когда pivot систематически оказывается минимальным или максимальным элементом. Рекуррентное соотношение: T(n) = T(n-1) + O(n).

Факторы влияния: Выбор опорного элемента оказывает критическое влияние на производительность.

7. Пирамидальная сортировка — Реализация на Java

7.1. Суть метода:
Алгоритм, который сначала строит из входного массива структуру данных "двоичная куча" (max-heap), а затем последовательно извлекает из нее максимальный элемент, помещая его в конец отсортированной части.

7.2. Объяснение работы алгоритма:

Из массива строится двоичная куча (max-heap).

Корень кучи (являющийся наибольшим элементом) перемещается в конец массива.

Куча перестраивается для оставшихся n-1 элементов.

Процедура повторяется до тех пор, пока куча не будет исчерпана.

Используемые конструкции Java:

heapify: Функция для поддержания свойства кучи (родитель >= потомков).

2*i+1, 2*i+2: Формулы для вычисления индексов дочерних узлов.

Рекурсия в heapify: Гарантирует сохранение свойства кучи во всем поддереве.

7.3. Пример выполнения:

Входные данные: 6, затем 12 11 13 5 6 7

Выходные данные: 5 6 7 11 12 13

7.4. Детальный анализ временной сложности:

Все случаи — O(n log n): Время работы не зависит от исходной упорядоченности.

Построение кучи — O(n): Хотя heapify имеет сложность O(log n), построение всей кучи требует только O(n) операций.

Извлечение элементов — O(n log n): Каждое из n извлечений требует O(log n) операций для перестройки кучи.

Математическое обоснование: Общее время: O(n) + O(n log n) = O(n log n).

Раздел II: Алгоритмы поиска
8. Последовательный поиск — Реализация на Python

8.1. Суть метода:
Простейший алгоритм поиска, заключающийся в последовательном переборе каждого элемента коллекции и сравнении его с искомым значением до нахождения совпадения.

8.2. Объяснение работы алгоритма:

Алгоритм последовательно проверяет каждый элемент массива.

Сравнивает текущий элемент с искомым значением.

Если элемент обнаружен, возвращает его индекс.

Если после проверки всего массива элемент не найден, возвращает -1.

Используемые конструкции Python:

for ... in range(): Цикл для перебора индексов массива.

if arr[i] == target: Сравнение текущего элемента с целевым.

return: Оператор для возврата результата.

8.3. Пример выполнения:

Входные данные: 7, массив 3 5 2 7 9 1 4, искомое 7

Выходные данные: Элемент найден на позиции: 3

8.4. Детальный анализ временной сложности:

Лучший случай — O(1): Искомый элемент находится на первой позиции.

Средний случай — O(n): В среднем требуется проверка n/2 элементов.

Худший случай — O(n): Элемент находится в конце или отсутствует.

Пространственная сложность: O(1).

9. Бинарный поиск — Реализация на C++

9.1. Суть метода:
Высокоэффективный алгоритм поиска в упорядоченном множестве, основанный на многократном делении пространства поиска пополам до тех пор, пока элемент не будет найден или пространство не будет исчерпано.

9.2. Объяснение работы алгоритма:

Алгоритм применим исключительно к отсортированным массивам.

На каждом шаге область поиска уменьшается вдвое.

Сравнивает средний элемент с искомым значением.

В зависимости от результата продолжает поиск в левой или правой половине.

Используемые конструкции C++:

while(left <= right): Условие продолжения поиска.

mid = left + (right - left) / 2: Безопасное вычисление середины для избежания переполнения.

9.3. Пример выполнения:

Входные данные: 10, массив 1 3 5 7 9 11 13 15 17 19, искомое 7

Выходные данные: Элемент найден на позиции: 3

9.4. Детальный анализ временной сложности:

Все случаи — O(log n): На каждом шаге размер области поиска уменьшается экспоненциально.

Математическое доказательство: После k итераций размер области поиска равен n / 2^k. Условие остановки: n / 2^k = 1, откуда k = log₂n.

Количество сравнений: В худшем случае log₂n + 1 сравнений.

10. Интерполяционный поиск — Реализация на Java

10.1. Суть метода:
Усовершенствованная версия бинарного поиска, которая предсказывает позицию искомого элемента на основе его значения относительно границ диапазона. Эффективен для равномерно распределенных данных.

10.2. Объяснение работы алгоритма:

Является улучшенной версией бинарного поиска.

Использует интерполяционную формулу для прогнозирования позиции.

Особенно эффективен при равномерном распределении данных.

На каждом шаге вычисляет вероятную позицию элемента.

Используемые конструкции Java:

target >= arr[low] && target <= arr[high]: Проверка нахождения цели в пределах текущего диапазона.

Интерполяционная формула: Основа алгоритма для предсказания позиции.

10.3. Пример выполнения:

Входные данные: 15, массив 10 ... 47, искомое 18

Выходные данные: Элемент найден на позиции: 4

10.4. Детальный анализ временной сложности:

Лучший случай — O(1): Элемент находится в точно предсказанной позиции.

Средний случай — O(log log n): При равномерном распределении данных.

Худший случай — O(n): При очень неравномерном распределении, когда алгоритм вырождается в линейный поиск.

11. Поиск Фибоначчи — Реализация на Python

11.1. Суть метода:
Эффективный алгоритм поиска в отсортированной коллекции, который использует числа Фибоначчи для определения позиций сравнения, что позволяет избежать операций деления.

11.2. Объяснение работы алгоритма:

Использует числа Фибоначчи для определения точек сравнения.

Применим только к отсортированным массивам.

Использует три последовательных числа Фибоначчи для определения области поиска.

На каждом шаге сужает область поиска, используя свойства чисел Фибоначчи.

Используемые конструкции Python:

min(offset + fib_m2, n - 1): Ограничение индекса пределами массива.

elif: Сокращение от else if для проверки дополнительного условия.

11.3. Пример выполнения:

Входные данные: 11, массив 10 ... 100, искомое 85

Выходные данные: Элемент найден на позиции: 8

11.4. Детальный анализ временной сложности:

Все случаи — O(log n): Аналогично бинарному поиску, но с другим коэффициентом.

Сравнение с бинарным поиском:

Бинарный поиск делит массив пополам.

Поиск Фибоначчи делит его в пропорции золотого сечения (≈1.618).

Количество сравнений: В худшем случае ≈1.44 * log₂n сравнений.

Преимущества: Избегает операции деления, что может быть выгодно на некоторых архитектурах.
