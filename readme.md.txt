1. Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве. Java

Объяснение работы алгоритма:

Алгоритм делит массив на две части: отсортированную (в начале) и неотсортированную (в конце)

На каждой итерации находится минимальный элемент в неотсортированной части массива

Найденный минимальный элемент меняется местами с первым элементом неотсортированной части

После каждой итерации отсортированная часть увеличивается на один элемент

Процесс повторяется до тех пор, пока весь массив не будет отсортирован

`int[]` - объявление массива целых чисел в Java
`for` - цикл с счетчиком, состоит из инициализации, условия и инкремента
`if` - условный оператор, выполняет код только если условие истинно
`Scanner` - класс для ввода данных с консили

Ввод: 5
64 25 12 22 11
Вывод: 11 12 22 25 64

Временная сложность: O(n²) во всех случаях (лучшем, среднем и худшем), где n - количество элементов в массиве. Это связано с тем, что алгоритм всегда выполняет двойной цикл, независимо от исходного порядка элементов.


2. Сортировка обменом (пузырьком) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется. Python

Объяснение работы алгоритма:

Алгоритм проходит по массиву многократно, сравнивая соседние элементы

Если два соседних элемента находятся в неправильном порядке, они меняются местами

На каждой итерации самый большой элемент "всплывает" в конец массива

Процесс повторяется до тех пор, пока массив не будет полностью отсортирован

`list` - встроенный тип данных Python для хранения упорядоченных коллекций
`for` - цикл перебора элементов последовательности, автоматически итерирует по `range()`
`range()` - функция генерации последовательности чисел с заданными параметрами
`if` - условный оператор, проверяющий булево выражение

Ввод: 7
64 34 25 12 22 11 90
Вывод: 11 12 22 25 34 64 90

Временная сложность: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (когда массив уже отсортирован).


3. Сортировка вставками — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место. C++

Объяснение работы алгоритма:

Алгоритм делит массив на отсортированную и неотсортированную части

Каждый новый элемент вставляется в правильную позицию в отсортированной части

Элементы большие чем вставляемый сдвигаются вправо

Процесс повторяется пока все элементы не будут вставлены в отсортированную часть

`vector` - контейнер стандартной библиотеки C++ для динамических массивов
`for` - цикл с объявлением итерационной переменной, выполняющий n-1 итераций
`while` - цикл с предварительной проверкой условия, выполняется пока условие истинно
`&&` - логический оператор И, оба условия должны быть истинны
`j--` - оператор декремента, уменьшает значение переменной на 1

Ввод: 5
12 11 13 5 6
Вывод: 5 6 11 12 13

Временная сложность: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (когда массив уже отсортирован).


4. Сортировка слиянием — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии. Java

Объяснение работы алгоритма:

Алгоритм использует стратегию "разделяй и властвуй"

Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы из одного элемента

Затем подмассивы сливаются обратно в отсортированном порядке

Процесс слияния сравнивает элементы из двух подмассивов и размещает их в правильном порядке

`void` - спецификатор типа для функций, которые не возвращают значения
Рекурсия - вызов функции самой себя с измененными параметрами
`System.arraycopy()` - метод копирования массивов в Java
`k++` - постинкремент: сначала используется значение, затем увеличивается

**Ввод:** 7
38 27 43 3 9 82 10
**Вывод:** 3 9 10 27 38 43 82

Временная сложность: O(n log n) во всех случаях (лучшем, среднем и худшем).


5. Сортировка Шелла — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу. Python

Объяснение работы алгоритма:

Алгоритм является улучшенной версией сортировки вставками

Сортировка выполняется с определенным шагом (gap), который постепенно уменьшается

На каждом шаге сортируются элементы, отстоящие друг от друга на расстоянии gap

Когда gap становится равным 1, алгоритм работает как обычная сортировка вставками

`len()` - встроенная функция, возвращает количество элементов в последовательности
`//` - оператор целочисленного деления (отбрасывает дробную часть)
`while` - цикл с условием, выполняющийся до тех пор пока условие истинно
`for...in range()` - цикл перебора числовой последовательности

Ввод: 5
12 34 54 2 3
Вывод: 2 3 12 34 54

Временная сложность: O(n²) в худшем случае, O(n log n) в лучшем случае.

6. Быстрая сортировка — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них. Python

Объяснение работы алгоритма:

Алгоритм использует стратегию "разделяй и властвуй"

Выбирается опорный элемент (pivot)

Массив разделяется на три части: элементы меньше pivot, равные pivot и больше pivot

Рекурсивно применяется к левой и правой частям

Объединяет результаты в отсортированный массив

`def` - ключевое слово для объявления пользовательской функции
`if len(arr) <= 1` - условие базового случая рекурсии
`return` - оператор возврата значения из функции
Генераторы списков - компактный способ фильтрации элементов

Ввод: 6
10 7 8 9 1 5
Вывод: 1 5 7 8 9 10

Временная сложность: O(n log n) в среднем случае, O(n²) в худшем случае.


7. Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка. Java

Объяснение работы алгоритма:

Алгоритм строит из массива двоичную кучу (max-heap)

Корень кучи (наибольший элемент) перемещается в конец массива

Куча перестраивается для оставшихся элементов

Процесс повторяется пока куча не опустеет

`heapify` - функция поддержки свойства кучи (родитель >= потомков)
`2*i+1, 2*i+2` - формулы для вычисления индексов левого и правого потомков
Рекурсия в heapify - гарантирует сохранение свойства кучи во всем поддереве

Ввод: 6
12 11 13 5 6 7
Вывод: 5 6 7 11 12 13

Временная сложность: O(n log n) во всех случаях.


8. Последовательный поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков. Python

Объяснение работы алгоритма:

Алгоритм последовательно проверяет каждый элемент массива

Сравнивает текущий элемент с искомым значением

Если элемент найден, возвращает его индекс

Если элемент не найден после проверки всего массива, возвращает -1

`for...in range()` - цикл перебора индексов массива
`if arr[i] == target` - сравнение текущего элемента с целевым значением
`return` - оператор возврата результата из функции

Ввод: 7
3 5 2 7 9 1 4
7
Вывод: Элемент найден на позиции: 3

Временная сложность: O(n) в худшем случае, O(1) в лучшем случае.


9. Бинарный поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах. C++

Объяснение работы алгоритма:

Алгоритм работает только с отсортированными массивами

На каждом шаге область поиска уменьшается вдвое

Сравнивает средний элемент с искомым значением

В зависимости от результата продолжает поиск в левой или правой половине

`while(left <= right)` - условие продолжения поиска (левая граница <= правой)
`mid = left + (right-left)/2` - безопасное вычисление середины (избегает переполнения)
`arr[mid] == target` - проверка найден ли элемент в средней позиции

Ввод: 10
1 3 5 7 9 11 13 15 17 19
7
Вывод: Элемент найден на позиции: 3

Временная сложность: O(log n) во всех случаях.


10. Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно. Java

Объяснение работы алгоритма:

Улучшенная версия бинарного поиска

Использует интерполяционную формулу для предсказания позиции искомого элемента

Особенно эффективен при равномерном распределении данных

На каждом шаге вычисляет вероятную позицию элемента на основе его значения

`target >= arr[low] && target <= arr[high]` - проверка что целевое значение в пределах текущего диапазона
Интерполяционная формула - основа алгоритма, предсказывает позицию элемента
`while` - цикл с условиями границ и значений

Ввод: 15
10 12 13 16 18 19 20 21 22 23 24 33 35 42 47
18
Вывод: Элемент найден на позиции: 4

Временная сложность: O(log log n) в среднем случае, O(n) в худшем случае.


11. Фибоначчи поиск — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения. Python

Объяснение работы алгоритма:

Алгоритм использует числа Фибоначчи для определения позиций сравнения

Работает только с отсортированными массивами

Использует три последовательных числа Фибоначчи для определения области поиска

На каждом шаге сужает область поиска используя свойства чисел Фибоначчи

`min(offset+fib_m2, n-1)` - ограничение индекса пределами массива
`elif` - сокращение от else if, проверка дополнительного условия
Числа Фибоначчи - математическая последовательность, используемая для деления

Ввод: 11
10 22 35 40 45 50 80 82 85 90 100
85
Вывод: Элемент найден на позиции: 8

Временная сложность: O(log n) во всех случаях.
