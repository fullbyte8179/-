1. Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве. Java

Объяснение работы алгоритма:

Алгоритм делит массив на две части: отсортированную (в начале) и неотсортированную (в конце)

На каждой итерации находится минимальный элемент в неотсортированной части массива

Найденный минимальный элемент меняется местами с первым элементом неотсортированной части

После каждой итерации отсортированная часть увеличивается на один элемент

Процесс повторяется до тех пор, пока весь массив не будет отсортирован

int[] - объявление массива целых чисел в Java
for - цикл с счетчиком, состоит из инициализации, условия и инкремента
if - условный оператор, выполняет код только если условие истинно
Scanner - класс для ввода данных с консоли

Ввод: 5
64 25 12 22 11
Вывод: 11 12 22 25 64

Детальный анализ временной сложности:

Лучший случай O(n²): Даже если массив уже отсортирован, алгоритм все равно выполняет полный перебор для поиска минимального элемента на каждой итерации. Количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2

Средний случай O(n²): В среднем требуется n/2 сравнений для поиска минимального элемента на каждой из n итераций. Общее количество операций: Σ(i=0 to n-1) Σ(j=i+1 to n-1) 1 = n(n-1)/2

Худший случай O(n²): При любом порядке элементов количество операций остается одинаковым. Алгоритм не адаптируется к исходной упорядоченности данных.

Количество сравнений: n(n-1)/2 ≈ O(n²)
Количество обменов: n-1 ≈ O(n)
Пространственная сложность: O(1) - сортировка на месте

---

2. Сортировка обменом (пузырьком) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется. Python

Объяснение работы алгоритма:

Алгоритм проходит по массиву многократно, сравнивая соседние элементы

Если два соседних элемента находятся в неправильном порядке, они меняются местами

На каждой итерации самый большой элемент "всплывает" в конец массива

Процесс повторяется до тех пор, пока массив не будет полностью отсортирован

list - встроенный тип данных Python для хранения упорядоченных коллекций
for - цикл перебора элементов последовательности, автоматически итерирует по range()
range() - функция генерации последовательности чисел с заданными параметрами
if - условный оператор, проверяющий булево выражение

Ввод: 7
64 34 25 12 22 11 90
Вывод: 11 12 22 25 34 64 90

Детальный анализ временной сложности:

Лучший случай O(n): Если массив уже отсортирован, внутренний цикл выполняется 1 раз за итерацию благодаря проверке условия. Количество сравнений: n-1

Средний случай O(n²): В среднем требуется n²/2 сравнений. Внешний цикл: n итераций, внутренний цикл: n-i-1 итераций. Общее: Σ(n-i-1) для i=0..n-1 = n(n-1)/2

Худший случай O(n²): При обратно отсортированном массиве выполняются все возможные сравнения и обмены. Количество сравнений: n(n-1)/2, количество обменов: n(n-1)/2

Математическое обоснование: Количество операций пропорционально квадрату размера массива из-за вложенных циклов

---

3. Сортировка вставками — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место. C++

Объяснение работы алгоритма:

Алгоритм делит массив на отсортированную и неотсортированную части

Каждый новый элемент вставляется в правильную позицию в отсортированной части

Элементы большие чем вставляемый сдвигаются вправо

Процесс повторяется пока все элементы не будут вставлены в отсортированную часть

vector - контейнер стандартной библиотеки C++ для динамических массивов
for - цикл с объявлением итерационной переменной, выполняющий n-1 итераций
while - цикл с предварительной проверкой условия, выполняется пока условие истинно
&& - логический оператор И, оба условия должны быть истинны
j-- - оператор декремента, уменьшает значение переменной на 1

Ввод: 5
12 11 13 5 6
Вывод: 5 6 11 12 13

Детальный анализ временной сложности:

Лучший случай O(n): Когда массив уже отсортирован, внутренний цикл while не выполняется. Количество сравнений: n-1, количество присваиваний: 0

Средний случай O(n²): В среднем каждый элемент сдвигается на n/4 позиций. Количество сравнений: ~n²/4, количество присваиваний: ~n²/4

Худший случай O(n²): При обратно отсортированном массиве каждый элемент сдвигается на i позиций. Количество сравнений: n(n-1)/2, количество присваиваний: n(n-1)/2

Анализ операций: Для i-го элемента требуется в среднем i/2 сравнений и i/2 присваиваний

---

4. Сортировка слиянием — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии. Java

Объяснение работы алгоритма:

Алгоритм использует стратегию "разделяй и властвуй"

Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы из одного элемента

Затем подмассивы сливаются обратно в отсортированном порядке

Процесс слияния сравнивает элементы из двух подмассивов и размещает их в правильном порядке

void - спецификатор типа для функций, которые не возвращают значения
Рекурсия - вызов функции самой себя с измененными параметрами
System.arraycopy() - метод копирования массивов в Java
k++ - постинкремент: сначала используется значение, затем увеличивается

Ввод: 7
38 27 43 3 9 82 10
Вывод: 3 9 10 27 38 43 82

Детальный анализ временной сложности:

Все случаи O(n log n): Алгоритм всегда делит массив пополам и выполняет слияние независимо от исходного порядка элементов

Математическое доказательство:
Рекуррентное соотношение: T(n) = 2T(n/2) + O(n)
По теореме о рекуррентных соотношениях: T(n) = O(n log n)
Глубина рекурсии: log₂n уровней
На каждом уровне: O(n) операций слияния
Общее: O(n) × O(log n) = O(n log n)

Пространственная сложность: O(n) - требуется дополнительная память для временных массивов

---

5. Сортировка Шелла — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу. Python

Объяснение работы алгоритма:

Алгоритм является улучшенной версией сортировки вставками

Сортировка выполняется с определенным шагом (gap), который постепенно уменьшается

На каждом шаге сортируются элементы, отстоящие друг от друга на расстоянии gap

Когда gap становится равным 1, алгоритм работает как обычная сортировка вставками

len() - встроенная функция, возвращает количество элементов в последовательности
// - оператор целочисленного деления (отбрасывает дробную часть)
while - цикл с условием, выполняющийся до тех пор пока условие истинно
for...in range() - цикл перебора числовой последовательности

Ввод: 5
12 34 54 2 3
Вывод: 2 3 12 34 54

Детальный анализ временной сложности:

Сложность зависит от последовательности gaps:
- Последовательность Шелла (n/2, n/4, ...): O(n²) в худшем случае
- Последовательность Хиббарда (2^k - 1): O(n^(3/2))
- Последовательность Кнута (3^k - 1)/2: O(n^(3/2))
- Последовательность Седжвика: O(n^(4/3))

Лучший случай O(n log n): При оптимальной последовательности промежутков и частично отсортированном массиве

Худший случай O(n²): При неудачной последовательности промежутков и обратно отсортированном массиве

Анализ: Эффективность зависит от того, насколько быстро алгоритм устраняет инверсии на ранних этапах

---

6. Быстрая сортировка — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них. Python

Объяснение работы алгоритма:

Алгоритм использует стратегию "разделяй и властвуй"

Выбирается опорный элемент (pivot)

Массив разделяется на три части: элементы меньше pivot, равные pivot и больше pivot

Рекурсивно применяется к левой и правой частям

Объединяет результаты в отсортированный массив

def - ключевое слово для объявления пользовательской функции
if len(arr) <= 1 - условие базового случая рекурсии
return - оператор возврата значения из функции
Генераторы списков - компактный способ фильтрации элементов

Ввод: 6
10 7 8 9 1 5
Вывод: 1 5 7 8 9 10

Детальный анализ временной сложности:

Лучший случай O(n log n): Когда pivot всегда делит массив пополам. Рекуррентное соотношение: T(n) = 2T(n/2) + O(n)

Средний случай O(n log n): В среднем pivot близок к медиане. Математическое ожидание времени работы: O(n log n)

Худший случай O(n²): Когда pivot всегда минимальный или максимальный элемент (уже отсортированный массив). Рекуррентное соотношение: T(n) = T(n-1) + O(n)

Факторы влияния: Выбор опорного элемента существенно влияет на производительность

---

7. Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка. Java

Объяснение работы алгоритма:

Алгоритм строит из массива двоичную кучу (max-heap)

Корень кучи (наибольший элемент) перемещается в конец массива

Куча перестраивается для оставшихся элементов

Процесс повторяется пока куча не опустеет

heapify - функция поддержки свойства кучи (родитель >= потомков)
2*i+1, 2*i+2 - формулы для вычисления индексов левого и правого потомков
Рекурсия в heapify - гарантирует сохранение свойства кучи во всем поддереве

Ввод: 6
12 11 13 5 6 7
Вывод: 5 6 7 11 12 13

Детальный анализ временной сложности:

Все случаи O(n log n): Время работы не зависит от исходного порядка элементов

Построение кучи O(n): Хотя heapify имеет сложность O(log n), построение всей кучи требует только O(n) операций благодаря тому, что большинство элементов находятся на нижних уровнях

Извлечение элементов O(n log n): Каждое из n извлечений требует O(log n) операций для перестройки кучи

Математическое обоснование:
Высота кучи: log₂n
Сумма высот всех узлов: O(n)
Общее время: O(n) + O(n log n) = O(n log n)

---

8. Последовательный поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков. Python

Объяснение работы алгоритма:

Алгоритм последовательно проверяет каждый элемент массива

Сравнивает текущий элемент с искомым значением

Если элемент найден, возвращает его индекс

Если элемент не найден после проверки всего массива, возвращает -1

for...in range() - цикл перебора индексов массива
if arr[i] == target - сравнение текущего элемента с целевым значением
return - оператор возврата результата из функции

Ввод: 7
3 5 2 7 9 1 4
7
Вывод: Элемент найден на позиции: 3

Детальный анализ временной сложности:

Лучший случай O(1): Когда искомый элемент находится на первой позиции. Требуется 1 сравнение

Средний случай O(n): В среднем требуется проверка n/2 элементов. Математическое ожидание: (n+1)/2 сравнений

Худший случай O(n): Когда элемент находится в конце массива или отсутствует. Требуется n сравнений

Пространственная сложность: O(1) - не требует дополнительной памяти

Эффективность: Подходит только для небольших массивов или когда поиск выполняется редко

---

9. Бинарный поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах. C++

Объяснение работы алгоритма:

Алгоритм работает только с отсортированными массивами

На каждом шаге область поиска уменьшается вдвое

Сравнивает средний элемент с искомым значением

В зависимости от результата продолжает поиск в левой или правой половине

while(left <= right) - условие продолжения поиска (левая граница <= правой)
mid = left + (right-left)/2 - безопасное вычисление середины (избегает переполнения)
arr[mid] == target - проверка найден ли элемент в средней позиции

Ввод: 10
1 3 5 7 9 11 13 15 17 19
7
Вывод: Элемент найден на позиции: 3

Детальный анализ временной сложности:

Все случаи O(log n): На каждом шаге размер области поиска уменьшается вдвое

Математическое доказательство:
После k итераций размер области поиска: n/2^k
Условие остановки: n/2^k = 1 ⇒ k = log₂n
Таким образом, максимальное количество итераций: ⌈log₂n⌉

Количество сравнений: В худшем случае log₂n + 1 сравнений

Эффективность: Экспоненциально быстрее последовательного поиска для больших массивов

---

10. Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно. Java

Объяснение работы алгоритма:

Улучшенная версия бинарного поиска

Использует интерполяционную формулу для предсказания позиции искомого элемента

Особенно эффективен при равномерном распределении данных

На каждом шаге вычисляет вероятную позицию элемента на основе его значения

target >= arr[low] && target <= arr[high] - проверка что целевое значение в пределах текущего диапазона
Интерполяционная формула - основа алгоритма, предсказывает позицию элемента
while - цикл с условиями границ и значений

Ввод: 15
10 12 13 16 18 19 20 21 22 23 24 33 35 42 47
18
Вывод: Элемент найден на позиции: 4

Детальный анализ временной сложности:

Лучший случай O(1): Когда элемент находится точно на предсказанной позиции

Средний случай O(log log n): При равномерном распределении данных. Каждая итерация уменьшает область поиска экспоненциально

Худший случай O(n): При очень неравномерном распределении (например, геометрической прогрессии). В этом случае алгоритм вырождается в последовательный поиск

Интерполяционная формула: pos = low + ((target - arr[low]) × (high - low)) / (arr[high] - arr[low])

Условия эффективности: Требуется равномерное распределение данных и возможность быстрого вычисления интерполяции

---

11. Фибоначчи поиск — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения. Python

Объяснение работы алгоритма:

Алгоритм использует числа Фибоначчи для определения позиций сравнения

Работает только с отсортированными массивами

Использует три последовательных числа Фибоначчи для определения области поиска

На каждом шаге сужает область поиска используя свойства чисел Фибоначчи

min(offset+fib_m2, n-1) - ограничение индекса пределами массива
elif - сокращение от else if, проверка дополнительного условия
Числа Фибоначчи - математическая последовательность, используемая для деления

Ввод: 11
10 22 35 40 45 50 80 82 85 90 100
85
Вывод: Элемент найден на позиции: 8

Детальный анализ временной сложности:

Все случаи O(log n): Как и бинарный поиск, но с другим коэффициентом

Сравнение с бинарным поиском:
- Бинарный поиск: делит всегда пополам
- Поиск Фибоначчи: делит в золотом сечении (≈1.618)

Количество сравнений: В худшем случае ≈1.44 × log₂n сравнений

Преимущества: Избегает деления, что может быть полезно на некоторых архитектурах

Недостатки: Более сложная реализация по сравнению с бинарным поиском

Область применения: Специализированные системы, где деление является дорогой операцией
